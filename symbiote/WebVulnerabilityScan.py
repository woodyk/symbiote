#!/usr/bin/env python3
#
# WebVulnerabilityScan.py
"""
Project Overview:
The `WebVulnerabilityScan.py` script is a comprehensive tool designed to detect
security vulnerabilities in websites by performing a detailed analysis of web pages,
server configurations, forms, and other security-critical elements. It combines
automated techniques for vulnerability scanning with detailed reporting to assist
in improving web security.

Purpose and Goals:
- Identify potential vulnerabilities across multiple categories, including:
    - Open ports, weak HTTP methods, and cryptographic weaknesses.
    - Misconfigured security headers, CORS issues, and sensitive information exposure.
    - XSS, SQL injection, CSRF, and directory traversal vulnerabilities.
    - Broken authentication, insecure file uploads, and more.
- Provide actionable recommendations for mitigating detected risks.
- Generate detailed reports summarizing the vulnerabilities found and the steps required
  to address them.

Key Features:
1. **Browser Automation and Web Page Analysis**:
   - Uses Selenium WebDriver for dynamic content analysis and interaction with forms.
   - Supports both Firefox and Chrome in headless or full-browser modes.
   - Extracts form details (inputs, actions, methods, encoding types) for security checks.

2. **Server and Network Security**:
   - Analyzes server headers for missing or misconfigured security settings (e.g., CSP, HSTS).
   - Checks open ports within a specified range using multithreaded scanning.
   - Resolves domains to IP addresses for further network-level analysis.

3. **Input Validation and Injection Testing**:
   - Tests forms for vulnerabilities such as SQL injection, XSS, directory traversal, and XXE.
   - Analyzes password fields for weak password policies and complexity rules.
   - Uses crafted payloads to simulate attack scenarios.

4. **Security Header Verification**:
   - Validates the presence and correctness of headers like X-Frame-Options,
     Strict-Transport-Security, and Content-Security-Policy.
   - Checks cookies for Secure and HttpOnly flags to prevent session hijacking.

5. **Misconfiguration Detection**:
   - Identifies issues with DNS records, CORS policies, directory listings, and HTTPS enforcement.
   - Detects open redirects and content spoofing vulnerabilities.

6. **Reporting and Extensibility**:
   - Generates comprehensive security reports with:
     - Detected vulnerabilities.
     - Server details and form analysis.
     - Recommendations for remediation.
   - Modular architecture allows easy addition of new vulnerability checks or integrations.

Methodologies:
- **Web Scraping and DOM Parsing**: Uses BeautifulSoup for static HTML analysis.
- **Dynamic Interaction**: Selenium WebDriver for engaging with dynamic content and simulating user inputs.
- **Regex-Based and Payload Testing**: Detects vulnerabilities through carefully crafted patterns and payloads.
- **Multithreading**: Enhances performance for tasks like port scanning.
- **REST API Usage**: Requests library facilitates HTTP interaction and analysis of headers and responses.

Extensibility:
- **Adding New Vulnerability Checks**:
  - Create a method in the `SecurityScanner` class and append it to the `scan` workflow.
- **Customizing Scans**:
  - Modify parameters (e.g., port ranges, payloads) to suit specific environments or requirements.
- **Integration with External Systems**:
  - Use the reporting output for integration with CI/CD pipelines or security dashboards.

Best Practices:
- Use headless browser mode for faster scans in production; switch to full-browser mode
  for debugging.
- Regularly update payloads and techniques to address emerging vulnerabilities.
- Validate input URLs and handle potential errors gracefully to avoid interruptions.

Reusable Prompt for Extensions:
- "Develop a security scanner to detect [specific vulnerability types]. Include support
  for dynamic content analysis, form validation, and comprehensive reporting."

Personal Style Alignment:
- Modular and extensible design ensures that individual components are independently
  testable and easy to update.
- Emphasis on actionable findings aligns the tool with practical use cases in security
  audits and compliance testing.
- Detailed logging and error handling enhance reliability and provide transparency
  during scans.

Example Usage:
```
scanner = SecurityScanner(headless=True, browser='chrome')
url = "https://example.com"
findings = scanner.scan(url)
print(findings)  # Outputs a JSON summary of vulnerabilities and scanning details.

report = scanner.generate_report()
print(report)  # Outputs a detailed human-readable report.
```
"""


import io
import os
import json
import time
import socket
from concurrent.futures import ThreadPoolExecutor
import dns.resolver
from urllib.parse import urljoin
import requests
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.common.exceptions import WebDriverException, TimeoutException, NoSuchElementException, ElementNotInteractableException
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
log(f"Loading SecurityScanner.")

class SecurityScanner:
    def __init__(self, headless=True, browser='firefox', page_load_timeout=30):
        self.headless = headless
        self.browser = browser
        self.page_load_timeout = page_load_timeout
        self.findings = []
        self.scanning_details = {
            'server_details': {},
            'form_details': [],
        }
        self.vulnerabilities_scanned = []  # List to store all the vulnerabilities we scan for

    def report_finding(self, issue, risk_level, description, action):
        """Collect findings into a list for the final report."""
        self.findings.append({
            'issue': issue,
            'risk': risk_level,
            'description': description,
            'action': action
        })

    def init_driver(self):
        """Initialize Selenium WebDriver with configurable browser and timeout."""
        try:
            if self.browser.lower() == 'firefox':
                options = FirefoxOptions()
                if self.headless:
                    options.add_argument('--headless')
                driver = webdriver.Firefox(options=options)
            elif self.browser.lower() == 'chrome':
                options = ChromeOptions()
                if self.headless:
                    options.add_argument('--headless')
                driver = webdriver.Chrome(options=options)
            else:
                raise ValueError("Browser must be 'firefox' or 'chrome'")
            driver.set_page_load_timeout(self.page_load_timeout)
            return driver
        except WebDriverException as e:
            log(f"Error initializing WebDriver: {e}")
            return None

    def analyze_site_features(self, url):
        """Analyze a website for input features, including GET/POST methods and forms."""
        log(f"Analyzing web site features...")
        driver = self.init_driver()
        if driver is None:
            log("WebDriver initialization failed.")
            return []

        try:
            log(f"Accessing URL: {url}")
            driver.get(url)
            time.sleep(2)  # Wait for dynamic content to load

            page_source = driver.page_source
            soup = BeautifulSoup(page_source, 'html.parser')

            forms = soup.find_all('form')
            features = []

            for form in forms:
                action = form.get('action')
                method = form.get('method', 'GET').upper()
                enctype = form.get('enctype', 'application/x-www-form-urlencoded')
                inputs = []

                for input_tag in form.find_all(['input', 'textarea', 'select', 'button']):
                    input_type = input_tag.get('type', 'text')
                    input_name = input_tag.get('name')
                    input_value = input_tag.get('value', '')

                    # Handle select elements
                    if input_tag.name == 'select':
                        options = []
                        selected_value = None
                        for option in input_tag.find_all('option'):
                            option_value = option.get('value') or option.text
                            if 'selected' in option.attrs:
                                selected_value = option_value
                            options.append(option_value)
                        inputs.append({
                            'type': 'select',
                            'name': input_name,
                            'options': options,
                            'selected': selected_value
                        })

                    # Handle radio buttons and checkboxes
                    elif input_type in ['radio', 'checkbox']:
                        is_checked = 'checked' in input_tag.attrs
                        inputs.append({
                            'type': input_type,
                            'name': input_name,
                            'value': input_value,
                            'checked': is_checked
                        })

                    # Handle hidden inputs
                    elif input_type == 'hidden':
                        inputs.append({
                            'type': input_type,
                            'name': input_name,
                            'value': input_value
                        })

                    # Handle buttons and submits
                    elif input_tag.name == 'button' or input_type in ['submit', 'button']:
                        inputs.append({
                            'type': input_type,
                            'name': input_name,
                            'value': input_value
                        })

                    # Handle other input types
                    else:
                        input_pattern = input_tag.get('pattern', None)
                        input_maxlength = input_tag.get('maxlength', None)
                        input_required = 'required' in input_tag.attrs

                        inputs.append({
                            'type': input_type,
                            'name': input_name,
                            'value': input_value,
                            'pattern': input_pattern,
                            'maxlength': input_maxlength,
                            'required': input_required
                        })

                form_details = {
                    'action': urljoin(url, action) if action else url,
                    'method': method,
                    'enctype': enctype,
                    'inputs': inputs
                }
                features.append(form_details)
                self.scanning_details['form_details'].append(form_details)

            return features

        except Exception as e:
            log(f"Error analyzing site features: {e}")
        finally:
            driver.quit()

    def check_open_ports(self, url, port_range=(1, 1024), timeout=0.5, max_workers=100):
        """Scan the target URL for open ports within a specified range with multithreading."""
        log(f"Checking for open ports range: {port_range}")
        self.vulnerabilities_scanned.append("Port Scanning")
        open_ports = []
        ip_address = self.resolve_domain_to_ip(url)

        def scan_port(port):
            """Check if a port is open on the target."""
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(timeout)
                result = sock.connect_ex((ip_address, port))
                if result == 0:
                    return port
            return None

        # Use ThreadPoolExecutor to scan ports concurrently
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = [executor.submit(scan_port, port) for port in range(port_range[0], port_range[1] + 1)]
            for future in futures:
                result = future.result()
                if result:
                    open_ports.append(result)

        if open_ports:
            self.report_finding(
                "Open Ports Detected",
                "MEDIUM",
                f"Open ports detected: {', '.join(map(str, open_ports))}",
                "Close unnecessary ports or restrict access via firewall."
            )
        else:
            log(f"No open ports detected on {ip_address}.") 

    def resolve_domain_to_ip(self, url):
        """Helper function to resolve a domain to an IP address."""
        domain = url.split("//")[-1].split("/")[0]  # Extract domain from URL
        try:
            ip_address = socket.gethostbyname(domain)
            return ip_address
        except socket.gaierror:
            log(f"Failed to resolve domain {domain} to an IP address.")
            return None

    def check_server_details(self, url):
        """Capture and report server details from headers."""
        log(f"Checking server details...")
        self.vulnerabilities_scanned.append("Server Information Disclosure")
        try:
            response = requests.get(url)
            server_headers = {
                'Server': response.headers.get('Server', 'Unknown'),
                'X-Powered-By': response.headers.get('X-Powered-By', 'Unknown'),
                'Strict-Transport-Security': response.headers.get('Strict-Transport-Security', 'Not Set'),
                'Content-Security-Policy': response.headers.get('Content-Security-Policy', 'Not Set')
            }
            self.scanning_details['server_details'] = server_headers

        except Exception as e:
            log(f"Error capturing server details...: {e}")

    def check_http_methods(self, url):
        """Check if the site allows insecure HTTP methods like PUT, DELETE, TRACE."""
        log(f"Checking http methods...")
        self.vulnerabilities_scanned.append("Insecure HTTP Methods")
        try:
            response = requests.options(url)
            allowed_methods = response.headers.get('Allow', '').upper()
            insecure_methods = ['PUT', 'DELETE', 'TRACE', 'OPTIONS']
            for method in insecure_methods:
                if method in allowed_methods:
                    self.report_finding(
                        "Insecure HTTP Methods",
                        "HIGH",
                        f"Site allows dangerous HTTP methods such as {method}.",
                        f"Disable methods like {method} unless explicitly needed."
                    )
        except Exception as e:
            log(f"Error checking HTTP methods...: {e}")

    def check_cors_misconfiguration(self, url):
        """Check for Cross-Origin Resource Sharing (CORS) misconfigurations."""
        log(f"Checking CORS configuration...")
        self.vulnerabilities_scanned.append("CORS Misconfiguration")
        try:
            response = requests.options(url)
            cors_header = response.headers.get('Access-Control-Allow-Origin', None)

            if cors_header == '*':
                self.report_finding(
                    "CORS Misconfiguration",
                    "HIGH",
                    "CORS policy allows access from any origin (`*`). This can expose sensitive information.",
                    "Restrict CORS policies to specific, trusted origins."
                )
            else:
                log(f"CORS header is properly configured....")
        except Exception as e:
            log(f"Error checking CORS misconfiguration...: {e}")

    def check_content_spoofing(self, url):
        """Check for content spoofing vulnerabilities."""
        log(f"Checking for content spoofing...")
        self.vulnerabilities_scanned.append("Content Spoofing")
        try:
            # Spoofing test involves injecting known spoof content into query parameters.
            test_payload = "SpoofedContent123"
            spoof_test_url = f"{url}?content={test_payload}"
            
            response = requests.get(spoof_test_url)
            if test_payload in response.text:
                self.report_finding(
                    "Content Spoofing Vulnerability",
                    "MEDIUM",
                    f"Page {url} reflects unsanitized content from query strings or user input, enabling content spoofing.",
                    "Ensure user inputs are properly sanitized and not reflected directly in the page."
                )
        except Exception as e:
            log(f"Error checking content spoofing...: {e}")

    def check_dns_misconfigurations(self, url):
        """Check for DNS misconfigurations."""
        log(f"Checking DNS...")
        self.vulnerabilities_scanned.append("DNS Misconfigurations")
        domain = url.split("//")[-1].split("/")[0]  # Extract domain from URL
        
        try:
            # Check for missing SPF or DMARC records
            try:
                dns.resolver.resolve(domain, 'TXT')
            except (dns.resolver.NoAnswer, dns.resolver.NXDOMAIN):
                self.report_finding(
                    "DNS Misconfiguration (SPF/DMARC)",
                    "MEDIUM",
                    f"No SPF or DMARC records found for {domain}.",
                    "Ensure SPF and DMARC records are correctly configured."
                )
        except Exception as e:
            log(f"Error checking DNS misconfigurations...: {e}")

    def check_http2_and_websocket_vulnerabilities(self, url):
        """Check for HTTP/2 and WebSocket vulnerabilities."""
        log(f"Checking HTTP/2 and WebSocket vulnerabilities...")
        self.vulnerabilities_scanned.append("HTTP/2 and WebSocket Vulnerabilities")
        try:
            response = requests.get(url)
            if "Upgrade" in response.headers and "websocket" in response.headers.get('Upgrade', '').lower():
                # Check WebSocket-related security issues
                self.report_finding(
                    "WebSocket Vulnerability",
                    "HIGH",
                    "WebSocket connections are allowed but no proper security checks (e.g., lack of origin checks).",
                    "Ensure proper security measures (e.g., origin checking) are in place for WebSocket connections."
                )
            if response.raw.version == 2:
                # Check for HTTP/2 vulnerabilities
                log(f"Site {url} supports HTTP/2. Ensure HTTP/2 specific security mechanisms are in place.")
        except Exception as e:
            log(f"Error checking HTTP/2 and WebSocket vulnerabilities...: {e}")

    def check_cryptographic_weaknesses(self, url):
        """Check for cryptographic weaknesses (weak hash algorithms, weak SSL/TLS versions)."""
        log(f"Checking cryptography...")
        self.vulnerabilities_scanned.append("Cryptographic Weaknesses")
        try:
            response = requests.get(url)
            ssl_version = response.raw.version

            # Check SSL/TLS version
            if ssl_version in [2, 3]:  # SSLv2 or SSLv3
                self.report_finding(
                    "Weak SSL/TLS Version",
                    "HIGH",
                    f"Site {url} uses deprecated SSLv{ssl_version}.",
                    "Use TLS 1.2 or higher for secure communications."
                )
            
            # Check for weak hash algorithms (example check for MD5/SHA1)
            if "MD5" in response.text or "SHA1" in response.text:
                self.report_finding(
                    "Weak Hash Algorithm Detected",
                    "HIGH",
                    "The site is using weak or deprecated cryptographic hashing algorithms (e.g., MD5, SHA1).",
                    "Use stronger cryptographic algorithms such as SHA-256 or SHA-3."
                )
        except Exception as e:
            log(f"Error checking cryptographic weaknesses...: {e}")

    def check_xss_vulnerability(self, url, form):
        """Check forms for potential XSS vulnerabilities using reflected XSS payload."""
        log(f"Checking XSS vulnerability...")
        self.vulnerabilities_scanned.append("Cross-Site Scripting (XSS)")
        xss_test_payload = "<script>alert('XSS')</script>"
        form_inputs = form['inputs']

        for input_field in form_inputs:
            if input_field['type'] in ['text', 'textarea']:
                input_field['value'] = xss_test_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form_inputs:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        log(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            # Check if the payload is reflected in the response
            if xss_test_payload in driver.page_source:
                self.report_finding(
                    "Cross-Site Scripting (XSS) Vulnerability",
                    "HIGH",
                    "Reflected XSS detected in form submission.",
                    "Ensure proper escaping and sanitization of user inputs."
                )
        finally:
            driver.quit()

    def check_csrf_protection(self, form):
        """Check if forms include anti-CSRF tokens."""
        log(f"Checking CSRF protection...")
        self.vulnerabilities_scanned.append("Cross-Site Request Forgery (CSRF)")
        csrf_tokens = [input_field for input_field in form['inputs'] if input_field.get('name') and 'csrf' in input_field['name'].lower()]
        if csrf_tokens:
            log(f"CSRF protection found: {csrf_tokens}")
        else:
            self.report_finding(
                "Missing CSRF Protection",
                "HIGH",
                "No CSRF protection detected in form.",
                "Add CSRF tokens to forms to prevent CSRF attacks."
            )

    def check_open_redirects(self, url, form):
        """Check for open redirect vulnerabilities in form inputs."""
        log(f"Checking for open redirects...")
        self.vulnerabilities_scanned.append("Open Redirects")
        redirect_test_payload = "https://malicious.com"
        for input_field in form['inputs']:
            input_name = input_field.get('name')
            if input_name and ('url' in input_name.lower() or 'redirect' in input_name.lower()):
                input_field['value'] = redirect_test_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form['inputs']:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.presence_of_element_located((By.NAME, input_field['name'])))
                        if element.get_attribute('type') in ['text', 'email', 'password', 'textarea']:
                            element.send_keys(input_field['value'])
                    except (ElementNotInteractableException, TimeoutException) as e:
                        log(f"Failed to interact with element '{input_field['name']}': {e}")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='submit'], button[type='submit']")))
                submit_button.click()
            except (NoSuchElementException, TimeoutException):
                driver.execute_script("document.querySelector('form').submit()")

            # Check if the payload is reflected in the URL (open redirect check)
            if redirect_test_payload in driver.current_url:
                self.report_finding(
                    "Open Redirect Vulnerability",
                    "HIGH",
                    "Form is vulnerable to open redirects.",
                    "Sanitize and validate URL/redirect parameters."
                )
        finally:
            driver.quit()

    def check_sensitive_information_exposure(self, url):
        """Check for sensitive information exposure in page content or response headers."""
        log(f"Checking for sensitive informaton...")
        self.vulnerabilities_scanned.append("Sensitive Information Exposure")
        response = requests.get(url)
        sensitive_keywords = ["API_KEY", "password", "AWS_SECRET", "admin", "secret"]
        if any(keyword in response.text for keyword in sensitive_keywords):
            self.report_finding(
                "Sensitive Information Exposure",
                "HIGH",
                f"Sensitive information such as API keys, passwords, or secrets exposed in page content at {url}.",
                "Ensure that sensitive information is not exposed in the response body or in the HTML source."
            )
        if "Server" in response.headers:
            log(f"Server information exposed in headers: {response.headers['Server']}")

    def check_https_enforcement(self, url):
        """Ensure HTTPS is enforced for secure connections."""
        log(f"Checking for HTTPS enforcement...")
        self.vulnerabilities_scanned.append("HTTPS Enforcement")
        if url.startswith('http://'):
            self.report_finding(
                "Unsecure HTTP Connection",
                "HIGH",
                f"HTTP used instead of HTTPS at {url}.",
                "Use HTTPS to encrypt communications and protect user data."
            )
        else:
            log(f"{url} is using HTTPS.")

    def check_clickjacking_protection(self, url):
        """Check for X-Frame-Options header to prevent clickjacking."""
        log(f"Checking for ClickJacking...")
        self.vulnerabilities_scanned.append("Clickjacking Protection")
        response = requests.get(url)
        if 'X-Frame-Options' not in response.headers:
            self.report_finding(
                "Missing X-Frame-Options Header",
                "HIGH",
                f"{url} is missing the X-Frame-Options header.",
                "Add X-Frame-Options header to protect against clickjacking attacks."
            )

    def check_security_headers(self, url):
        """Check for required security headers such as CSP, HSTS, and X-Content-Type-Options."""
        log(f"Checking security headers...")
        self.vulnerabilities_scanned.append("Security Headers (CSP, HSTS, X-Content-Type-Options)")
        response = requests.get(url)
        headers = response.headers
        required_headers = {
            'Content-Security-Policy': "Ensure strict content security.",
            'Strict-Transport-Security': "Enforce secure (HTTPS) connections.",
            'X-Content-Type-Options': "Prevent MIME-sniffing."
        }
        for header, recommendation in required_headers.items():
            if header not in headers:
                self.report_finding(
                    f"Missing {header} Header",
                    "MEDIUM",
                    f"{header} header is missing from the response.",
                    f"Add {header} to {recommendation}."
                )

    def check_directory_listing(self, url):
        """Check for directory listing vulnerabilities."""
        log(f"Checking for directory listings...")
        self.vulnerabilities_scanned.append("Directory Listing")
        common_directories = ['/uploads/', '/images/', '/backup/']
        for directory in common_directories:
            try:
                response = requests.get(urljoin(url, directory))
                if "Index of" in response.text:
                    self.report_finding(
                        "Directory Listing Enabled",
                        "MEDIUM",
                        f"Directory listing is enabled at {url}{directory}.",
                        "Disable directory listing to prevent unauthorized access."
                    )
            except Exception as e:
                log(f"Error checking directory listing...: {e}")

    def check_cookie_security(self, url):
        """Check cookie security flags (Secure, HttpOnly) for proper cookie protection."""
        log(f"Checking cookie security...")
        self.vulnerabilities_scanned.append("Cookie Security (Secure, HttpOnly)")
        response = requests.get(url)
        cookies = response.cookies
        for cookie in cookies:
            if not cookie.secure:
                self.report_finding(
                    "Insecure Cookie",
                    "MEDIUM",
                    f"Cookie '{cookie.name}' is not marked as Secure.",
                    "Ensure cookies are marked as Secure."
                )
            if not cookie.has_nonstandard_attr('HttpOnly'):
                self.report_finding(
                    "Insecure Cookie",
                    "MEDIUM",
                    f"Cookie '{cookie.name}' is not marked as HttpOnly.",
                    "Ensure cookies are marked as HttpOnly to prevent JavaScript access."
                )

    def check_password_policy(self, form):
        """Check password inputs for weak password policies."""
        log(f"Checking password policy...")
        self.vulnerabilities_scanned.append("Weak Password Policy")
        for input_field in form['inputs']:
            if input_field['type'] == 'password':
                minlength = input_field.get('minlength', 0)
                pattern = input_field.get('pattern', '')
                if int(minlength) < 8:
                    self.report_finding(
                        "Weak Password Policy",
                        "MEDIUM",
                        "Password policy allows passwords shorter than 8 characters.",
                        "Set minimum password length to 8 or more characters."
                    )
                if not pattern:
                    self.report_finding(
                        "Weak Password Complexity",
                        "MEDIUM",
                        "No complexity enforced in password field.",
                        "Enforce complexity rules such as uppercase, lowercase, numbers, and symbols."
                    )

    def check_sql_injection(self, url, form):
        """Check for SQL Injection vulnerabilities."""
        log(f"Checking for SQL injection for forms...")
        self.vulnerabilities_scanned.append("SQL Injection")
        sql_injection_payload = "' OR '1'='1"
        form_inputs = form['inputs']

        for input_field in form_inputs:
            if input_field['type'] in ['text', 'textarea']:
                input_field['value'] = sql_injection_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form_inputs:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        log(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            if "syntax error" in driver.page_source or "SQL" in driver.page_source:
                self.report_finding(
                    "SQL Injection Vulnerability",
                    "HIGH",
                    "Potential SQL injection vulnerability detected via form submission.",
                    "Use parameterized queries or prepared statements to mitigate this issue."
                )
        finally:
            driver.quit()

    def check_directory_traversal(self, url, form):
        """Check for Directory Traversal vulnerabilities."""
        log(f"Checking directory traversal for forms...")
        self.vulnerabilities_scanned.append("Directory Traversal")
        directory_traversal_payload = "../../../../etc/passwd"
        form_inputs = form['inputs']

        for input_field in form_inputs:
            if input_field['type'] in ['text', 'textarea']:
                input_field['value'] = directory_traversal_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form_inputs:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        log(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            if "root:x" in driver.page_source or "bin/bash" in driver.page_source:
                self.report_finding(
                    "Directory Traversal Vulnerability",
                    "HIGH",
                    "Potential directory traversal vulnerability detected via form submission.",
                    "Sanitize and validate file paths and user inputs."
                )
        finally:
            driver.quit()

    def check_broken_authentication(self, url):
        """Check for broken authentication vulnerabilities."""
        log(f"Checking for broken authentication...")
        self.vulnerabilities_scanned.append("Broken Authentication")
        weak_passwords = ['password', '123456', 'admin', 'password1']

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            # Simulate brute-force attack on login form (if available)
            for password in weak_passwords:
                try:
                    username_field = wait.until(EC.element_to_be_clickable((By.NAME, "username")))
                    password_field = wait.until(EC.element_to_be_clickable((By.NAME, "password")))
                    username_field.send_keys("admin")
                    password_field.send_keys(password)

                    submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                    submit_button.click()

                    if "dashboard" in driver.page_source:
                        self.report_finding(
                            "Broken Authentication",
                            "HIGH",
                            f"Login page is vulnerable to brute-force attacks using weak passwords (e.g., {password}).",
                            "Implement strong lockout policies and CAPTCHAs to mitigate brute-force attacks."
                        )
                except TimeoutException:
                    log("Unable to interact with the login form.")
        finally:
            driver.quit()

    def check_insecure_file_upload(self, url, form):
        """Check for Insecure File Upload vulnerabilities."""
        log(f"Checking for insecure file uploads...")
        self.vulnerabilities_scanned.append("Insecure File Upload")
        malicious_file_payload = "/path/to/malicious_file.php"

        for input_field in form['inputs']:
            if input_field['type'] == 'file':
                input_field['value'] = malicious_file_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form['inputs']:
                if input_field.get('name') and input_field['type'] == 'file':
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        log(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            if "upload successful" in driver.page_source or "file.php" in driver.page_source:
                self.report_finding(
                    "Insecure File Upload",
                    "HIGH",
                    "Unrestricted or insecure file upload detected.",
                    "Restrict file uploads by content type and validate file extensions."
                )
        finally:
            driver.quit()

    def check_session_management(self, url):
        """Check for session management vulnerabilities."""
        log(f"Checking session management...")
        self.vulnerabilities_scanned.append("Session Management")
        response = requests.get(url)
        cookies = response.cookies

        for cookie in cookies:
            if not cookie.secure or not cookie.has_nonstandard_attr('HttpOnly'):
                self.report_finding(
                    "Weak Session Management",
                    "MEDIUM",
                    f"Session cookie '{cookie.name}' is missing Secure or HttpOnly flags.",
                    "Ensure session cookies are marked as Secure and HttpOnly to prevent session hijacking."
                )

            if "PHPSESSID" in cookie.name or "JSESSIONID" in cookie.name:
                self.report_finding(
                    "Session Management",
                    "MEDIUM",
                    "Session ID is vulnerable to exposure or fixation.",
                    "Use strong session ID mechanisms and rotate session IDs after login."
                )

    def check_xxe_vulnerability(self, url, form):
        """Check for XXE vulnerabilities via XML inputs."""
        log(f"Checking XXE vulnerabilities...")
        self.vulnerabilities_scanned.append("XML External Entity (XXE)")
        xxe_payload = """<?xml version="1.0"?>
            <!DOCTYPE foo [<!ELEMENT foo ANY >
            <!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&xxe;</foo>"""

        form_inputs = form['inputs']

        for input_field in form_inputs:
            if input_field['type'] in ['text', 'textarea']:
                input_field['value'] = xxe_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form_inputs:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        log(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            if "root:x" in driver.page_source or "bin/bash" in driver.page_source:
                self.report_finding(
                    "XXE Vulnerability",
                    "HIGH",
                    "External XML entities processed without validation.",
                    "Disable external entity processing in XML parsers."
                )
        finally:
            driver.quit()

    def check_clickjacking_protection_js(self, url):
        """Check for JavaScript framebusting protection against clickjacking."""
        log(f"Checking ClickJacking protection...")
        self.vulnerabilities_scanned.append("Clickjacking (JavaScript Framebusting)")
        response = requests.get(url)

        if "if (self !== top)" in response.text or "window.top.location" in response.text:
            self.report_finding(
                "Clickjacking Protection (JavaScript)",
                "LOW",
                "JavaScript framebusting script detected.",
                "Consider using the X-Frame-Options header in addition to JavaScript framebusting techniques."
            )

    def scan(self, url):
        """Scan the given site for security vulnerabilities and input features."""
        log(f"Running vulnerability scan for url:{url}")
        self.check_open_ports(url)
        self.analyze_site_features(url)
        self.check_server_details(url)
        self.check_http_methods(url)
        self.check_https_enforcement(url)
        self.check_security_headers(url)
        self.check_clickjacking_protection(url)
        self.check_clickjacking_protection_js(url)
        self.check_sensitive_information_exposure(url)
        self.check_directory_listing(url)
        self.check_cookie_security(url)
        self.check_session_management(url)
        self.check_broken_authentication(url)
        self.check_cors_misconfiguration(url)
        self.check_content_spoofing(url)
        self.check_dns_misconfigurations(url)
        self.check_http2_and_websocket_vulnerabilities(url)
        self.check_cryptographic_weaknesses(url)

        # Check form-related security checks
        for form in self.scanning_details['form_details']:
            log(f"Analyzing form: {form}")
            self.check_csrf_protection(form)
            self.check_xss_vulnerability(url, form)
            self.check_open_redirects(url, form)
            self.check_password_policy(form)
            self.check_sql_injection(url, form)
            self.check_directory_traversal(url, form)
            self.check_insecure_file_upload(url, form)
            self.check_xxe_vulnerability(url, form)

        # Return findings and scanned details as a JSON document
        return json.dumps({
            "findings": self.findings,
            "scanning_details": self.scanning_details
        }, indent=4)

    def generate_report(self):
        """Generate a comprehensive security report with scanning details."""
        log(f"Generating report...")
        report_output = io.StringIO()

        # Section 1: Vulnerabilities Scanned For
        report_output.write("Vulnerabilities Scanned For\n" + "=" * 30 + "\n")
        for vulnerability in self.vulnerabilities_scanned:
            report_output.write(f"- {vulnerability}\n")
        report_output.write("-" * 40 + "\n")

        # Section 2: Detected Vulnerabilities
        report_output.write("Detected Vulnerabilities\n" + "=" * 30 + "\n")
        if self.findings:
            for finding in self.findings:
                report_output.write(f"Issue: {finding['issue']}\n")
                report_output.write(f"Risk Level: {finding['risk']}\n")
                report_output.write(f"Description: {finding['description']}\n")
                report_output.write(f"Action: {finding['action']}\n")
                report_output.write("-" * 40 + "\n")
        else:
            report_output.write("No vulnerabilities detected.\n")

        # Section 3: Scanning Details (What was Scanned)
        report_output.write("\nScanning Details\n" + "=" * 30 + "\n")

        # Server Details
        report_output.write("Server Details\n" + "-" * 30 + "\n")
        for key, value in self.scanning_details['server_details'].items():
            report_output.write(f"{key}: {value}\n")
        report_output.write("-" * 40 + "\n")

        # Form Analysis
        report_output.write("Form Analysis\n" + "=" * 30 + "\n")
        if self.scanning_details['form_details']:
            for i, form in enumerate(self.scanning_details['form_details'], 1):
                report_output.write(f"Form {i}:\n")
                report_output.write(f"  - Action: {form['action']}\n")
                report_output.write(f"  - Method: {form['method']}\n")
                report_output.write(f"  - Encoding Type: {form['enctype']}\n")
                report_output.write("  - Inputs:\n")
                for input_field in form['inputs']:
                    report_output.write(f"    - Name: {input_field.get('name', 'Unnamed')}\n")
                    report_output.write(f"    - Type: {input_field['type']}\n")
                    report_output.write(f"    - Value: {input_field.get('value', '')}\n")
                    report_output.write("-" * 40 + "\n")

        report_content = report_output.getvalue()
        report_output.close()
        return report_content

# Example usage
if __name__ == "__main__":
    scanner = SecurityScanner(headless=False, browser='firefox')
    site_url = 'https://smallroom.com'

    # Run the scan
    json_result = scanner.scan(site_url)

    # Generate and print the report
    report = scanner.generate_report()
    print(report)

    print(json_result)

