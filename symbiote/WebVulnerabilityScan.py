#!/usr/bin/env python3
#
# WebVulnerabilityScan.py

import io
import os
import json
import logging
import time
import socket
from concurrent.futures import ThreadPoolExecutor
import dns.resolver
from urllib.parse import urljoin
import requests
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.common.exceptions import WebDriverException, TimeoutException, NoSuchElementException, ElementNotInteractableException
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# Configure logging
logging.basicConfig(level=logging.ERROR)

class SecurityScanner:
    def __init__(self, headless=True, browser='firefox', page_load_timeout=30):
        self.headless = headless
        self.browser = browser
        self.page_load_timeout = page_load_timeout
        self.findings = []
        self.scanning_details = {
            'server_details': {},
            'form_details': [],
        }
        self.vulnerabilities_scanned = []  # List to store all the vulnerabilities we scan for

    def report_finding(self, issue, risk_level, description, action):
        """Collect findings into a list for the final report."""
        self.findings.append({
            'issue': issue,
            'risk': risk_level,
            'description': description,
            'action': action
        })

    def init_driver(self):
        """Initialize Selenium WebDriver with configurable browser and timeout."""
        try:
            if self.browser.lower() == 'firefox':
                options = FirefoxOptions()
                if self.headless:
                    options.add_argument('--headless')
                driver = webdriver.Firefox(options=options)
            elif self.browser.lower() == 'chrome':
                options = ChromeOptions()
                if self.headless:
                    options.add_argument('--headless')
                driver = webdriver.Chrome(options=options)
            else:
                raise ValueError("Browser must be 'firefox' or 'chrome'")
            driver.set_page_load_timeout(self.page_load_timeout)
            return driver
        except WebDriverException as e:
            logging.error(f"Error initializing WebDriver: {e}")
            return None

    def analyze_site_features(self, url):
        """Analyze a website for input features, including GET/POST methods and forms."""
        driver = self.init_driver()
        if driver is None:
            logging.error("WebDriver initialization failed.")
            return []

        try:
            logging.info(f"Accessing URL: {url}")
            driver.get(url)
            time.sleep(2)  # Wait for dynamic content to load

            page_source = driver.page_source
            soup = BeautifulSoup(page_source, 'html.parser')

            forms = soup.find_all('form')
            features = []

            for form in forms:
                action = form.get('action')
                method = form.get('method', 'GET').upper()
                enctype = form.get('enctype', 'application/x-www-form-urlencoded')
                inputs = []

                for input_tag in form.find_all(['input', 'textarea', 'select', 'button']):
                    input_type = input_tag.get('type', 'text')
                    input_name = input_tag.get('name')
                    input_value = input_tag.get('value', '')

                    # Handle select elements
                    if input_tag.name == 'select':
                        options = []
                        selected_value = None
                        for option in input_tag.find_all('option'):
                            option_value = option.get('value') or option.text
                            if 'selected' in option.attrs:
                                selected_value = option_value
                            options.append(option_value)
                        inputs.append({
                            'type': 'select',
                            'name': input_name,
                            'options': options,
                            'selected': selected_value
                        })

                    # Handle radio buttons and checkboxes
                    elif input_type in ['radio', 'checkbox']:
                        is_checked = 'checked' in input_tag.attrs
                        inputs.append({
                            'type': input_type,
                            'name': input_name,
                            'value': input_value,
                            'checked': is_checked
                        })

                    # Handle hidden inputs
                    elif input_type == 'hidden':
                        inputs.append({
                            'type': input_type,
                            'name': input_name,
                            'value': input_value
                        })

                    # Handle buttons and submits
                    elif input_tag.name == 'button' or input_type in ['submit', 'button']:
                        inputs.append({
                            'type': input_type,
                            'name': input_name,
                            'value': input_value
                        })

                    # Handle other input types
                    else:
                        input_pattern = input_tag.get('pattern', None)
                        input_maxlength = input_tag.get('maxlength', None)
                        input_required = 'required' in input_tag.attrs

                        inputs.append({
                            'type': input_type,
                            'name': input_name,
                            'value': input_value,
                            'pattern': input_pattern,
                            'maxlength': input_maxlength,
                            'required': input_required
                        })

                form_details = {
                    'action': urljoin(url, action) if action else url,
                    'method': method,
                    'enctype': enctype,
                    'inputs': inputs
                }
                features.append(form_details)
                self.scanning_details['form_details'].append(form_details)

            return features

        except Exception as e:
            logging.error(f"Error analyzing site features: {e}")
        finally:
            driver.quit()

    def check_open_ports(self, url, port_range=(1, 1024), timeout=0.5, max_workers=100):
        """Scan the target URL for open ports within a specified range with multithreading."""
        self.vulnerabilities_scanned.append("Port Scanning")
        open_ports = []
        ip_address = self.resolve_domain_to_ip(url)

        def scan_port(port):
            """Check if a port is open on the target."""
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(timeout)
                result = sock.connect_ex((ip_address, port))
                if result == 0:
                    return port
            return None

        # Use ThreadPoolExecutor to scan ports concurrently
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = [executor.submit(scan_port, port) for port in range(port_range[0], port_range[1] + 1)]
            for future in futures:
                result = future.result()
                if result:
                    open_ports.append(result)

        if open_ports:
            self.report_finding(
                "Open Ports Detected",
                "MEDIUM",
                f"Open ports detected: {', '.join(map(str, open_ports))}",
                "Close unnecessary ports or restrict access via firewall."
            )
        else:
            logging.info(f"No open ports detected on {ip_address}.") 

    def resolve_domain_to_ip(self, url):
        """Helper function to resolve a domain to an IP address."""
        domain = url.split("//")[-1].split("/")[0]  # Extract domain from URL
        try:
            ip_address = socket.gethostbyname(domain)
            return ip_address
        except socket.gaierror:
            logging.error(f"Failed to resolve domain {domain} to an IP address.")
            return None

    def check_server_details(self, url):
        """Capture and report server details from headers."""
        self.vulnerabilities_scanned.append("Server Information Disclosure")
        try:
            response = requests.get(url)
            server_headers = {
                'Server': response.headers.get('Server', 'Unknown'),
                'X-Powered-By': response.headers.get('X-Powered-By', 'Unknown'),
                'Strict-Transport-Security': response.headers.get('Strict-Transport-Security', 'Not Set'),
                'Content-Security-Policy': response.headers.get('Content-Security-Policy', 'Not Set')
            }
            self.scanning_details['server_details'] = server_headers

        except Exception as e:
            logging.error(f"Error capturing server details for {url}: {e}")

    def check_http_methods(self, url):
        """Check if the site allows insecure HTTP methods like PUT, DELETE, TRACE."""
        self.vulnerabilities_scanned.append("Insecure HTTP Methods")
        try:
            response = requests.options(url)
            allowed_methods = response.headers.get('Allow', '').upper()
            insecure_methods = ['PUT', 'DELETE', 'TRACE', 'OPTIONS']
            for method in insecure_methods:
                if method in allowed_methods:
                    self.report_finding(
                        "Insecure HTTP Methods",
                        "HIGH",
                        f"Site allows dangerous HTTP methods such as {method}.",
                        f"Disable methods like {method} unless explicitly needed."
                    )
        except Exception as e:
            logging.error(f"Error checking HTTP methods for {url}: {e}")

    def check_cors_misconfiguration(self, url):
        """Check for Cross-Origin Resource Sharing (CORS) misconfigurations."""
        self.vulnerabilities_scanned.append("CORS Misconfiguration")
        try:
            response = requests.options(url)
            cors_header = response.headers.get('Access-Control-Allow-Origin', None)

            if cors_header == '*':
                self.report_finding(
                    "CORS Misconfiguration",
                    "HIGH",
                    "CORS policy allows access from any origin (`*`). This can expose sensitive information.",
                    "Restrict CORS policies to specific, trusted origins."
                )
            else:
                logging.info(f"CORS header is properly configured for {url}.")
        except Exception as e:
            logging.error(f"Error checking CORS misconfiguration for {url}: {e}")

    def check_content_spoofing(self, url):
        """Check for content spoofing vulnerabilities."""
        self.vulnerabilities_scanned.append("Content Spoofing")
        try:
            # Spoofing test involves injecting known spoof content into query parameters.
            test_payload = "SpoofedContent123"
            spoof_test_url = f"{url}?content={test_payload}"
            
            response = requests.get(spoof_test_url)
            if test_payload in response.text:
                self.report_finding(
                    "Content Spoofing Vulnerability",
                    "MEDIUM",
                    f"Page {url} reflects unsanitized content from query strings or user input, enabling content spoofing.",
                    "Ensure user inputs are properly sanitized and not reflected directly in the page."
                )
        except Exception as e:
            logging.error(f"Error checking content spoofing for {url}: {e}")

    def check_dns_misconfigurations(self, url):
        """Check for DNS misconfigurations."""
        self.vulnerabilities_scanned.append("DNS Misconfigurations")
        domain = url.split("//")[-1].split("/")[0]  # Extract domain from URL
        
        try:
            # Check for missing SPF or DMARC records
            try:
                dns.resolver.resolve(domain, 'TXT')
            except (dns.resolver.NoAnswer, dns.resolver.NXDOMAIN):
                self.report_finding(
                    "DNS Misconfiguration (SPF/DMARC)",
                    "MEDIUM",
                    f"No SPF or DMARC records found for {domain}.",
                    "Ensure SPF and DMARC records are correctly configured."
                )
        except Exception as e:
            logging.error(f"Error checking DNS misconfigurations for {url}: {e}")

    def check_http2_and_websocket_vulnerabilities(self, url):
        """Check for HTTP/2 and WebSocket vulnerabilities."""
        self.vulnerabilities_scanned.append("HTTP/2 and WebSocket Vulnerabilities")
        try:
            response = requests.get(url)
            if "Upgrade" in response.headers and "websocket" in response.headers.get('Upgrade', '').lower():
                # Check WebSocket-related security issues
                self.report_finding(
                    "WebSocket Vulnerability",
                    "HIGH",
                    "WebSocket connections are allowed but no proper security checks (e.g., lack of origin checks).",
                    "Ensure proper security measures (e.g., origin checking) are in place for WebSocket connections."
                )
            if response.raw.version == 2:
                # Check for HTTP/2 vulnerabilities
                logging.info(f"Site {url} supports HTTP/2. Ensure HTTP/2 specific security mechanisms are in place.")
        except Exception as e:
            logging.error(f"Error checking HTTP/2 and WebSocket vulnerabilities for {url}: {e}")

    def check_cryptographic_weaknesses(self, url):
        """Check for cryptographic weaknesses (weak hash algorithms, weak SSL/TLS versions)."""
        self.vulnerabilities_scanned.append("Cryptographic Weaknesses")
        try:
            response = requests.get(url)
            ssl_version = response.raw.version

            # Check SSL/TLS version
            if ssl_version in [2, 3]:  # SSLv2 or SSLv3
                self.report_finding(
                    "Weak SSL/TLS Version",
                    "HIGH",
                    f"Site {url} uses deprecated SSLv{ssl_version}.",
                    "Use TLS 1.2 or higher for secure communications."
                )
            
            # Check for weak hash algorithms (example check for MD5/SHA1)
            if "MD5" in response.text or "SHA1" in response.text:
                self.report_finding(
                    "Weak Hash Algorithm Detected",
                    "HIGH",
                    "The site is using weak or deprecated cryptographic hashing algorithms (e.g., MD5, SHA1).",
                    "Use stronger cryptographic algorithms such as SHA-256 or SHA-3."
                )
        except Exception as e:
            logging.error(f"Error checking cryptographic weaknesses for {url}: {e}")

    def check_xss_vulnerability(self, url, form):
        """Check forms for potential XSS vulnerabilities using reflected XSS payload."""
        self.vulnerabilities_scanned.append("Cross-Site Scripting (XSS)")
        xss_test_payload = "<script>alert('XSS')</script>"
        form_inputs = form['inputs']

        for input_field in form_inputs:
            if input_field['type'] in ['text', 'textarea']:
                input_field['value'] = xss_test_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form_inputs:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        logging.warning(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            # Check if the payload is reflected in the response
            if xss_test_payload in driver.page_source:
                self.report_finding(
                    "Cross-Site Scripting (XSS) Vulnerability",
                    "HIGH",
                    "Reflected XSS detected in form submission.",
                    "Ensure proper escaping and sanitization of user inputs."
                )
        finally:
            driver.quit()

    def check_csrf_protection(self, form):
        """Check if forms include anti-CSRF tokens."""
        self.vulnerabilities_scanned.append("Cross-Site Request Forgery (CSRF)")
        csrf_tokens = [input_field for input_field in form['inputs'] if input_field.get('name') and 'csrf' in input_field['name'].lower()]
        if csrf_tokens:
            logging.info(f"CSRF protection found: {csrf_tokens}")
        else:
            self.report_finding(
                "Missing CSRF Protection",
                "HIGH",
                "No CSRF protection detected in form.",
                "Add CSRF tokens to forms to prevent CSRF attacks."
            )

    def check_open_redirects(self, url, form):
        """Check for open redirect vulnerabilities in form inputs."""
        self.vulnerabilities_scanned.append("Open Redirects")
        redirect_test_payload = "https://malicious.com"
        for input_field in form['inputs']:
            input_name = input_field.get('name')
            if input_name and ('url' in input_name.lower() or 'redirect' in input_name.lower()):
                input_field['value'] = redirect_test_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form['inputs']:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.presence_of_element_located((By.NAME, input_field['name'])))
                        if element.get_attribute('type') in ['text', 'email', 'password', 'textarea']:
                            element.send_keys(input_field['value'])
                    except (ElementNotInteractableException, TimeoutException) as e:
                        logging.warning(f"Failed to interact with element '{input_field['name']}': {e}")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='submit'], button[type='submit']")))
                submit_button.click()
            except (NoSuchElementException, TimeoutException):
                driver.execute_script("document.querySelector('form').submit()")

            # Check if the payload is reflected in the URL (open redirect check)
            if redirect_test_payload in driver.current_url:
                self.report_finding(
                    "Open Redirect Vulnerability",
                    "HIGH",
                    "Form is vulnerable to open redirects.",
                    "Sanitize and validate URL/redirect parameters."
                )
        finally:
            driver.quit()

    def check_sensitive_information_exposure(self, url):
        """Check for sensitive information exposure in page content or response headers."""
        self.vulnerabilities_scanned.append("Sensitive Information Exposure")
        response = requests.get(url)
        sensitive_keywords = ["API_KEY", "password", "AWS_SECRET", "admin", "secret"]
        if any(keyword in response.text for keyword in sensitive_keywords):
            self.report_finding(
                "Sensitive Information Exposure",
                "HIGH",
                f"Sensitive information such as API keys, passwords, or secrets exposed in page content at {url}.",
                "Ensure that sensitive information is not exposed in the response body or in the HTML source."
            )
        if "Server" in response.headers:
            logging.info(f"Server information exposed in headers: {response.headers['Server']}")

    def check_https_enforcement(self, url):
        """Ensure HTTPS is enforced for secure connections."""
        self.vulnerabilities_scanned.append("HTTPS Enforcement")
        if url.startswith('http://'):
            self.report_finding(
                "Unsecure HTTP Connection",
                "HIGH",
                f"HTTP used instead of HTTPS at {url}.",
                "Use HTTPS to encrypt communications and protect user data."
            )
        else:
            logging.info(f"{url} is using HTTPS.")

    def check_clickjacking_protection(self, url):
        """Check for X-Frame-Options header to prevent clickjacking."""
        self.vulnerabilities_scanned.append("Clickjacking Protection")
        response = requests.get(url)
        if 'X-Frame-Options' not in response.headers:
            self.report_finding(
                "Missing X-Frame-Options Header",
                "HIGH",
                f"{url} is missing the X-Frame-Options header.",
                "Add X-Frame-Options header to protect against clickjacking attacks."
            )

    def check_security_headers(self, url):
        """Check for required security headers such as CSP, HSTS, and X-Content-Type-Options."""
        self.vulnerabilities_scanned.append("Security Headers (CSP, HSTS, X-Content-Type-Options)")
        response = requests.get(url)
        headers = response.headers
        required_headers = {
            'Content-Security-Policy': "Ensure strict content security.",
            'Strict-Transport-Security': "Enforce secure (HTTPS) connections.",
            'X-Content-Type-Options': "Prevent MIME-sniffing."
        }
        for header, recommendation in required_headers.items():
            if header not in headers:
                self.report_finding(
                    f"Missing {header} Header",
                    "MEDIUM",
                    f"{header} header is missing from the response.",
                    f"Add {header} to {recommendation}."
                )

    def check_directory_listing(self, url):
        """Check for directory listing vulnerabilities."""
        self.vulnerabilities_scanned.append("Directory Listing")
        common_directories = ['/uploads/', '/images/', '/backup/']
        for directory in common_directories:
            try:
                response = requests.get(urljoin(url, directory))
                if "Index of" in response.text:
                    self.report_finding(
                        "Directory Listing Enabled",
                        "MEDIUM",
                        f"Directory listing is enabled at {url}{directory}.",
                        "Disable directory listing to prevent unauthorized access."
                    )
            except Exception as e:
                logging.error(f"Error checking directory listing for {url}: {e}")

    def check_cookie_security(self, url):
        """Check cookie security flags (Secure, HttpOnly) for proper cookie protection."""
        self.vulnerabilities_scanned.append("Cookie Security (Secure, HttpOnly)")
        response = requests.get(url)
        cookies = response.cookies
        for cookie in cookies:
            if not cookie.secure:
                self.report_finding(
                    "Insecure Cookie",
                    "MEDIUM",
                    f"Cookie '{cookie.name}' is not marked as Secure.",
                    "Ensure cookies are marked as Secure."
                )
            if not cookie.has_nonstandard_attr('HttpOnly'):
                self.report_finding(
                    "Insecure Cookie",
                    "MEDIUM",
                    f"Cookie '{cookie.name}' is not marked as HttpOnly.",
                    "Ensure cookies are marked as HttpOnly to prevent JavaScript access."
                )

    def check_password_policy(self, form):
        """Check password inputs for weak password policies."""
        self.vulnerabilities_scanned.append("Weak Password Policy")
        for input_field in form['inputs']:
            if input_field['type'] == 'password':
                minlength = input_field.get('minlength', 0)
                pattern = input_field.get('pattern', '')
                if int(minlength) < 8:
                    self.report_finding(
                        "Weak Password Policy",
                        "MEDIUM",
                        "Password policy allows passwords shorter than 8 characters.",
                        "Set minimum password length to 8 or more characters."
                    )
                if not pattern:
                    self.report_finding(
                        "Weak Password Complexity",
                        "MEDIUM",
                        "No complexity enforced in password field.",
                        "Enforce complexity rules such as uppercase, lowercase, numbers, and symbols."
                    )

    def check_sql_injection(self, url, form):
        """Check for SQL Injection vulnerabilities."""
        self.vulnerabilities_scanned.append("SQL Injection")
        sql_injection_payload = "' OR '1'='1"
        form_inputs = form['inputs']

        for input_field in form_inputs:
            if input_field['type'] in ['text', 'textarea']:
                input_field['value'] = sql_injection_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form_inputs:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        logging.warning(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            if "syntax error" in driver.page_source or "SQL" in driver.page_source:
                self.report_finding(
                    "SQL Injection Vulnerability",
                    "HIGH",
                    "Potential SQL injection vulnerability detected via form submission.",
                    "Use parameterized queries or prepared statements to mitigate this issue."
                )
        finally:
            driver.quit()

    def check_directory_traversal(self, url, form):
        """Check for Directory Traversal vulnerabilities."""
        self.vulnerabilities_scanned.append("Directory Traversal")
        directory_traversal_payload = "../../../../etc/passwd"
        form_inputs = form['inputs']

        for input_field in form_inputs:
            if input_field['type'] in ['text', 'textarea']:
                input_field['value'] = directory_traversal_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form_inputs:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        logging.warning(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            if "root:x" in driver.page_source or "bin/bash" in driver.page_source:
                self.report_finding(
                    "Directory Traversal Vulnerability",
                    "HIGH",
                    "Potential directory traversal vulnerability detected via form submission.",
                    "Sanitize and validate file paths and user inputs."
                )
        finally:
            driver.quit()

    def check_broken_authentication(self, url):
        """Check for broken authentication vulnerabilities."""
        self.vulnerabilities_scanned.append("Broken Authentication")
        weak_passwords = ['password', '123456', 'admin', 'password1']

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            # Simulate brute-force attack on login form (if available)
            for password in weak_passwords:
                try:
                    username_field = wait.until(EC.element_to_be_clickable((By.NAME, "username")))
                    password_field = wait.until(EC.element_to_be_clickable((By.NAME, "password")))
                    username_field.send_keys("admin")
                    password_field.send_keys(password)

                    submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                    submit_button.click()

                    if "dashboard" in driver.page_source:
                        self.report_finding(
                            "Broken Authentication",
                            "HIGH",
                            f"Login page is vulnerable to brute-force attacks using weak passwords (e.g., {password}).",
                            "Implement strong lockout policies and CAPTCHAs to mitigate brute-force attacks."
                        )
                except TimeoutException:
                    logging.warning("Unable to interact with the login form.")
        finally:
            driver.quit()

    def check_insecure_file_upload(self, url, form):
        """Check for Insecure File Upload vulnerabilities."""
        self.vulnerabilities_scanned.append("Insecure File Upload")
        malicious_file_payload = "/path/to/malicious_file.php"

        for input_field in form['inputs']:
            if input_field['type'] == 'file':
                input_field['value'] = malicious_file_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form['inputs']:
                if input_field.get('name') and input_field['type'] == 'file':
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        logging.warning(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            if "upload successful" in driver.page_source or "file.php" in driver.page_source:
                self.report_finding(
                    "Insecure File Upload",
                    "HIGH",
                    "Unrestricted or insecure file upload detected.",
                    "Restrict file uploads by content type and validate file extensions."
                )
        finally:
            driver.quit()

    def check_session_management(self, url):
        """Check for session management vulnerabilities."""
        self.vulnerabilities_scanned.append("Session Management")
        response = requests.get(url)
        cookies = response.cookies

        for cookie in cookies:
            if not cookie.secure or not cookie.has_nonstandard_attr('HttpOnly'):
                self.report_finding(
                    "Weak Session Management",
                    "MEDIUM",
                    f"Session cookie '{cookie.name}' is missing Secure or HttpOnly flags.",
                    "Ensure session cookies are marked as Secure and HttpOnly to prevent session hijacking."
                )

            if "PHPSESSID" in cookie.name or "JSESSIONID" in cookie.name:
                self.report_finding(
                    "Session Management",
                    "MEDIUM",
                    "Session ID is vulnerable to exposure or fixation.",
                    "Use strong session ID mechanisms and rotate session IDs after login."
                )

    def check_xxe_vulnerability(self, url, form):
        """Check for XXE vulnerabilities via XML inputs."""
        self.vulnerabilities_scanned.append("XML External Entity (XXE)")
        xxe_payload = """<?xml version="1.0"?>
            <!DOCTYPE foo [<!ELEMENT foo ANY >
            <!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&xxe;</foo>"""

        form_inputs = form['inputs']

        for input_field in form_inputs:
            if input_field['type'] in ['text', 'textarea']:
                input_field['value'] = xxe_payload

        driver = self.init_driver()
        try:
            driver.get(url)
            wait = WebDriverWait(driver, 10)

            for input_field in form_inputs:
                if input_field.get('name'):
                    try:
                        element = wait.until(EC.element_to_be_clickable((By.NAME, input_field['name'])))
                        element.send_keys(input_field['value'])
                    except TimeoutException:
                        logging.warning(f"Input element with name '{input_field['name']}' is not interactable.")

            try:
                submit_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
                submit_button.click()
            except TimeoutException:
                driver.execute_script("document.querySelector('button[type=\"submit\"]').click()")

            if "root:x" in driver.page_source or "bin/bash" in driver.page_source:
                self.report_finding(
                    "XXE Vulnerability",
                    "HIGH",
                    "External XML entities processed without validation.",
                    "Disable external entity processing in XML parsers."
                )
        finally:
            driver.quit()

    def check_clickjacking_protection_js(self, url):
        """Check for JavaScript framebusting protection against clickjacking."""
        self.vulnerabilities_scanned.append("Clickjacking (JavaScript Framebusting)")
        response = requests.get(url)

        if "if (self !== top)" in response.text or "window.top.location" in response.text:
            self.report_finding(
                "Clickjacking Protection (JavaScript)",
                "LOW",
                "JavaScript framebusting script detected.",
                "Consider using the X-Frame-Options header in addition to JavaScript framebusting techniques."
            )

    def scan(self, url):
        """Scan the given site for security vulnerabilities and input features."""
        self.check_open_ports(url)
        self.analyze_site_features(url)
        self.check_server_details(url)
        self.check_http_methods(url)
        self.check_https_enforcement(url)
        self.check_security_headers(url)
        self.check_clickjacking_protection(url)
        self.check_clickjacking_protection_js(url)
        self.check_sensitive_information_exposure(url)
        self.check_directory_listing(url)
        self.check_cookie_security(url)
        self.check_session_management(url)
        self.check_broken_authentication(url)
        self.check_cors_misconfiguration(url)
        self.check_content_spoofing(url)
        self.check_dns_misconfigurations(url)
        self.check_http2_and_websocket_vulnerabilities(url)
        self.check_cryptographic_weaknesses(url)

        # Check form-related security checks
        for form in self.scanning_details['form_details']:
            self.check_csrf_protection(form)
            self.check_xss_vulnerability(url, form)
            self.check_open_redirects(url, form)
            self.check_password_policy(form)
            self.check_sql_injection(url, form)
            self.check_directory_traversal(url, form)
            self.check_insecure_file_upload(url, form)
            self.check_xxe_vulnerability(url, form)

        # Return findings and scanned details as a JSON document
        return json.dumps({
            "findings": self.findings,
            "scanning_details": self.scanning_details
        }, indent=4)

    def generate_report(self):
        """Generate a comprehensive security report with scanning details."""
        report_output = io.StringIO()

        # Section 1: Vulnerabilities Scanned For
        report_output.write("Vulnerabilities Scanned For\n" + "=" * 30 + "\n")
        for vulnerability in self.vulnerabilities_scanned:
            report_output.write(f"- {vulnerability}\n")
        report_output.write("-" * 40 + "\n")

        # Section 2: Detected Vulnerabilities
        report_output.write("Detected Vulnerabilities\n" + "=" * 30 + "\n")
        if self.findings:
            for finding in self.findings:
                report_output.write(f"Issue: {finding['issue']}\n")
                report_output.write(f"Risk Level: {finding['risk']}\n")
                report_output.write(f"Description: {finding['description']}\n")
                report_output.write(f"Action: {finding['action']}\n")
                report_output.write("-" * 40 + "\n")
        else:
            report_output.write("No vulnerabilities detected.\n")

        # Section 3: Scanning Details (What was Scanned)
        report_output.write("\nScanning Details\n" + "=" * 30 + "\n")

        # Server Details
        report_output.write("Server Details\n" + "-" * 30 + "\n")
        for key, value in self.scanning_details['server_details'].items():
            report_output.write(f"{key}: {value}\n")
        report_output.write("-" * 40 + "\n")

        # Form Analysis
        report_output.write("Form Analysis\n" + "=" * 30 + "\n")
        if self.scanning_details['form_details']:
            for i, form in enumerate(self.scanning_details['form_details'], 1):
                report_output.write(f"Form {i}:\n")
                report_output.write(f"  - Action: {form['action']}\n")
                report_output.write(f"  - Method: {form['method']}\n")
                report_output.write(f"  - Encoding Type: {form['enctype']}\n")
                report_output.write("  - Inputs:\n")
                for input_field in form['inputs']:
                    report_output.write(f"    - Name: {input_field.get('name', 'Unnamed')}\n")
                    report_output.write(f"    - Type: {input_field['type']}\n")
                    report_output.write(f"    - Value: {input_field.get('value', '')}\n")
                    report_output.write("-" * 40 + "\n")

        report_content = report_output.getvalue()
        report_output.close()
        return report_content

# Example usage
if __name__ == "__main__":
    scanner = SecurityScanner(headless=False, browser='firefox')
    site_url = 'https://smallroom.com'

    # Run the scan
    json_result = scanner.scan(site_url)

    # Generate and print the report
    report = scanner.generate_report()
    print(report)

    print(json_result)

